"""
Preparar una función
determinar si un número en multiplo de 9
Un conjunto que analizara la función, sera el intervalo entre 500 a 3000
resultado RDD(A) solo número divisores de 9 y RDD(B) 
número que son todo lo contrario
"""
%pyspark

import numpy as np

def multiploNueve(x):
    if x % 9 == 0:
        print("prueba")
        RDDA = x
        #RDDA = RDD.map(multiploNueve)
    else:
        return x

RDD = sc.parallelize(np.arange(500,3000))

RDDB = RDD.map(multiploNueve)
RDDA = RDDA.filter(lambda x: x is not None)
RDDB = RDDB.filter(lambda x: x is not None)
print (RDDA.collect())
print (RDDB.collect())



%pyspark

import numpy as np

def multiploNueve(x):
    if x % 9 == 0:
        RDDA = x
    else:
        return x

RDD = sc.parallelize(np.arange(500,3000))

RDDB = RDD.map(multiploNueve)
A2   = RDDA.filter(lambda x: x%2 ==0 and x%5 == 0) 
A3   = RDDA.filter(lambda x: x>600)
B2   = RDDB.filter(lambda x: x<700 and x is not None)
B3   = RDDB.filter(lambda x: x>=500 and x is not None)
print ('A2',A2.collect())
print ('A3',A3.collect())
print ('B2',B2.collect())
print ('B3',B3.collect())

%pyspark

import numpy as np

def multiploNueve(x):
    if x % 9 == 0:
        RDDA = x
    else:
        return x

RDD = sc.parallelize(np.arange(500,3000))

RDDB = RDD.map(multiploNueve)
A2   = RDDA.filter(lambda x: x%2 ==0 and x%5 == 0) 
A3   = RDDA.filter(lambda x: x>600)
B2   = RDDB.filter(lambda x: x<700 and x is not None)
B3   = RDDB.filter(lambda x: x>=500 and x is not None)
from test_helper import Test
Test.assertEquals(A2.collect(),[540, 630, 720, 810, 900, 990, 1080, 1170, 1260, 1350, 1440, 1530, 1620, 1710, 1800, 1890, 1980, 2070, 2160, 2250, 2340, 2430, 2520, 2610, 2700, 2790, 2880, 2970])
Test.assertEquals(A2.collect(),[540,550,650,850,1000])
Test.assertEquals(A3.collect(),[603, 612, 621, 630, 639, 648, 657, 666, 675, 684, 693, 702, 711, 720, 729, 738, 747, 756, 765, 774, 783, 792, 801, 810, 819, 828, 837, 846, 855, 864, 873, 882, 891, 900, 909, 918, 927, 936, 945, 954, 963, 972, 981, 990, 999, 1008, 1017, 1026, 1035, 1044, 1053, 1062, 1071, 1080, 1089, 1098, 1107, 1116, 1125, 1134, 1143, 1152, 1161, 1170, 1179, 1188, 1197, 1206, 1215, 1224, 1233, 1242, 1251, 1260, 1269, 1278, 1287, 1296, 1305, 1314, 1323, 1332, 1341, 1350, 1359, 1368, 1377, 1386, 1395, 1404, 1413, 1422, 1431, 1440, 1449, 1458, 1467, 1476, 1485, 1494, 1503, 1512, 1521, 1530, 1539, 1548, 1557, 1566, 1575, 1584, 1593, 1602, 1611, 1620, 1629, 1638, 1647, 1656, 1665, 1674, 1683, 1692, 1701, 1710, 1719, 1728, 1737, 1746, 1755, 1764, 1773, 1782, 1791, 1800, 1809, 1818, 1827, 1836, 1845, 1854, 1863, 1872, 1881, 1890, 1899, 1908, 1917, 1926, 1935, 1944, 1953, 1962, 1971, 1980, 1989, 1998, 2007, 2016, 2025, 2034, 2043, 2052, 2061, 2070, 2079, 2088, 2097, 2106, 2115, 2124, 2133, 2142, 2151, 2160, 2169, 2178, 2187, 2196, 2205, 2214, 2223, 2232, 2241, 2250, 2259, 2268, 2277, 2286, 2295, 2304, 2313, 2322, 2331, 2340, 2349, 2358, 2367, 2376, 2385, 2394, 2403, 2412, 2421, 2430, 2439, 2448, 2457, 2466, 2475, 2484, 2493, 2502, 2511, 2520, 2529, 2538, 2547, 2556, 2565, 2574, 2583, 2592, 2601, 2610, 2619, 2628, 2637, 2646, 2655, 2664, 2673, 2682, 2691, 2700, 2709, 2718, 2727, 2736, 2745, 2754, 2763, 2772, 2781, 2790, 2799, 2808, 2817, 2826, 2835, 2844, 2853, 2862, 2871, 2880, 2889, 2898, 2907, 2916, 2925, 2934, 2943, 2952, 2961, 2970, 2979, 2988, 2997])
Test.assertEquals(A3.collect(),[603, 612, 621, 630, 639, 648, 657, 666, 675, 684, 693, 702, 711, 720, 729, 738, 747, 756, 765, 774, 783, 792, 801, 810, 819, 828, 837, 846, 855, 864, 873, 882, 891, 900, 909, 918, 927, 936, 945, 954, 963, 972, 981, 990, 999, 1008, 1017, 1026, 1035, 1044, 1053, 1062, 1071, 1080, 1089, 1098, 1107, 1116, 1125, 1134, 1143, 2655, 2664, 2673, 2682, 2691, 2700, 2709, 2718, 2727, 2736, 2745, 2754, 2763, 2772, 2781, 2790, 2799, 2808, 2817, 2826, 2835, 2844, 2853, 2862, 2871, 2880, 2889, 2898, 2907, 2916, 2925, 2934, 2943, 2952, 2961, 2970, 2979, 2988, 2997])
Test.assertEquals(B2.collect(),[500, 501, 502, 503, 505, 506, 507, 508, 509, 510, 511, 512, 514, 515, 516, 517, 518, 519, 520, 521, 523, 524, 525, 526, 527, 528, 529, 530, 532, 533, 534, 535, 536, 537, 538, 539, 541, 542, 543, 544, 545, 546, 547, 548, 550, 551, 552, 553, 554, 555, 556, 557, 559, 560, 561, 562, 563, 564, 565, 566, 568, 569, 570, 571, 572, 573, 574, 575, 577, 578, 579, 580, 581, 582, 583, 584, 586, 587, 588, 589, 590, 591, 592, 593, 595, 596, 597, 598, 599, 600, 601, 602, 604, 605, 606, 607, 608, 609, 610, 611, 613, 614, 615, 616, 617, 618, 619, 620, 622, 623, 624, 625, 626, 627, 628, 629, 631, 632, 633, 634, 635, 636, 637, 638, 640, 641, 642, 643, 644, 645, 646, 647, 649, 650, 651, 652, 653, 654, 655, 656, 658, 659, 660, 661, 662, 663, 664, 665, 667, 668, 669, 670, 671, 672, 673, 674, 676, 677, 678, 679, 680, 681, 682, 683, 685, 686, 687, 688, 689, 690, 691, 692, 694, 695, 696, 697, 698, 699])

Test.assertEquals(B2.collect(),[500, 501])
Test.assertEquals(B3.collect(),[500, 501, 502, 503, 505, 506, 507, 508, 509, 510, 511, 512, 514, 515, 516, 517, 518, 519, 520, 521, 523, 524, 525, 526, 527, 528, 529, 530, 532, 533, 534, 535, 536, 537, 538, 539, 541, 542, 543, 544,  2885, 2886, 2887, 2888, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2899, 2900, 2901, 2902, 2903, 2904, 2905, 2906, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2926, 2927])



%pyspark
import numpy as np

def multiploNueve(x):
    if x % 9 == 0:
        RDDA = x
    else:
        return x

RDD = sc.parallelize(np.arange(500,3000))

RDDB = RDD.map(multiploNueve)
A2   = RDDA.filter(lambda x: x%2 ==0 and x%5 == 0 and x is not None)
cantA2   = A2.count()
A3   = RDDA.filter(lambda x: x>600 and x is not None)
cantA3   = A3.count()
B2   = RDDB.filter(lambda x: x<700 and x is not None)
cantB2 = B2.count()
B3   = RDDB.filter(lambda x: x>=500 and x is not None)
cantB3 = B3.count()

print ('A2',A2.glom().collect())
print ('cantA2',cantA2)
print ('A3',A3.glom().collect())
print ('cantA3',cantA3)
print ('B2',B2.glom().collect())
print ('cantB2',cantB2)
print ('B3',B3.glom().collect())
print ('cantB3',cantB3)